# Project Scaffolding & npm Publishing Notes

This document summarizes key concepts for creating, structuring, and publishing a Node.js/TypeScript project to npm.

---

## 1. Understanding `package.json` and `package-lock.json`

### `package.json` - The Manifest

- **Purpose**: Your project's "source of truth". It declares metadata, scripts, and dependencies.
- **Editable**: You manually edit this file to add dependencies or change project info.
- **Dependencies**: Specifies dependencies with version ranges (e.g., `^1.2.3`, `~4.5.6`). This tells npm which versions are acceptable.

### `package-lock.json` - The Lockfile

- **Purpose**: To guarantee **reproducible builds**. It records the _exact_ version of every package and sub-dependency that was installed.
- **Not Editable**: This file is auto-generated by `npm install`. You should **never** edit it manually. If you need to update it, modify `package.json` and run `npm install` again.
- **Benefit**: Ensures that every developer on a team, and every deployment, uses the exact same code, preventing "works on my machine" issues.

---

## 2. `dependencies` vs. `devDependencies`

This separation is crucial for keeping published packages lean.

### `dependencies`

- **When they're needed**: At **runtime**. These are libraries your compiled code needs to execute.
- **Example**: A web framework like `express` or a validation library like `zod` that your application logic calls directly.
- **Installation**: When a user installs your package (`npm install your-package`), only these dependencies are installed.

### `devDependencies`

- **When they're needed**: Only during **development**. These are tools for building, testing, and formatting your code.
- **Example**: `typescript` (to compile TS to JS), `jest` (for testing), `eslint` (for linting), `prettier` (for formatting).
- **Installation**: These are _not_ installed when a user installs your package. They are only installed when someone clones your repository and runs `npm install`.

---

## 3. Core `package.json` Fields for Publishing

- **`name`**: The package's unique identifier on npm.
  - **Rules**: Must be all lowercase. Can contain hyphens (`-`) but not underscores (`_`) or spaces.
- **`version`**: The current version, which must follow **Semantic Versioning (SemVer)** (`MAJOR.MINOR.PATCH`).
- **`main`**: The **entry point for library usage**. This is the file that gets loaded when someone uses `require('your-package')`. It should point to the compiled JavaScript file (e.g., `dist/index.js`).
- **`bin`**: Defines **command-line executables**. It maps a command name to a file that should be executed.
  - **Example**: `"bin": { "pizza-validator": "dist/cli.js" }` allows users to run `pizza-validator` from their terminal.
- **`types`**: Points to the main TypeScript declaration file (e.g., `dist/index.d.ts`), providing type information for TypeScript users.

---

## 4. How npm Packages and Modules Work

### The `require()` and `import` Process

1. A user calls `require('your-package')` or `import { func } from 'your-package'`.
2. Node.js finds your package in the `node_modules` directory.
3. It reads `package.json` and looks for the `main` field.
4. It **executes** the file specified in `main` (e.g., `dist/index.js`).
5. The value returned by `require()` is the `module.exports` object from that file. All `export` statements contribute to this object.

### `default` vs. Named Exports (Best Practices)

- **Named Exports (Recommended for Libraries)**: Allows users to import only the specific pieces they need, which enables **tree-shaking** (bundlers can remove unused code).

  ```typescript
  // In your library (e.g., src/index.ts)
  export { validatePizza } from "./validate";
  export { formatPizza } from "./utils";

  // User's code
  const { validatePizza } = require("your-package");
  ```

- **Default Export**: Exports a single value. It's less flexible for libraries with multiple functions and hinders tree-shaking.

  ```typescript
  // In your library
  export default { validatePizza, formatPizza };

  // User's code
  const myPackage = require("your-package");
  myPackage.validatePizza();
  ```

**Best Practice**: Use named exports for library entry points (`index.ts`) to create a clear, tree-shakeable public API.

---

## 5. TypeScript Concepts

### Discriminated Unions

A powerful pattern for handling objects that can have different shapes. It uses a common "discriminator" field (usually a string literal) to help TypeScript narrow down the type.

- **Benefit**: Provides strong type safety. If you check the discriminator's value, TypeScript automatically knows which other fields are available.

  ```typescript
  type Response = { status: "success"; data: string[] } | { status: "error"; code: number };

  function handleResponse(res: Response) {
    if (res.status === "success") {
      console.log(res.data); // TypeScript knows `data` exists
    } else {
      console.log(res.code); // TypeScript knows `code` exists
    }
  }
  ```

### `typeof` vs. `instanceof`

- **`typeof`**: A JavaScript operator that returns a **string** indicating a value's **primitive type** (`"string"`, `"number"`, `"object"`, `"function"`). It's not useful for distinguishing between different kinds of objects (e.g., an `Error` vs. a `Date` are both `"object"`).
- **`instanceof`**: A JavaScript operator that checks if an object is an **instance of a specific class**. It's essential for error handling and working with complex objects.

  ```typescript
  try {
    // ...
  } catch (e) {
    if (e instanceof ZodError) {
      // Correct way to check for a specific error type
      console.error(e.issues);
    }
  }
  ```

---

## 6. Zod for Data Validation

### Core Idea

Zod is a "TypeScript-first" schema declaration and validation library. You define a schema, and Zod can both validate data against it and infer a static TypeScript type from it.

### Key Functions

- **`z.object({...})`**: Defines the shape of an object.
- **`.parse(data)`**: Validates data against a schema. It **throws a `ZodError`** if validation fails and returns the typed data if it succeeds.
- **`z.infer<typeof MySchema>`**: Extracts a static TypeScript type from a schema. This is crucial for type safety.

  ```typescript
  import { z } from "zod";

  const UserSchema = z.object({ name: z.string() });
  type User = z.infer<typeof UserSchema>; // type User = { name: string; }

  const data = { name: "Aiden" };
  const user: User = UserSchema.parse(data); // `user` is now fully typed
  ```

### Error Handling

Always wrap `.parse()` in a `try...catch` block and check for `ZodError` to handle validation failures gracefully.

---

## 7. Node.js CLI and File System

### Reading Command-Line Arguments

- Use `process.argv` to get an array of command-line arguments.
- `process.argv.slice(2)` gives you only the arguments provided by the user (skipping the `node` executable and script path).

### Reading Files

- The `fs` (File System) module is built into Node.js.
- **`fs.readFileSync(path, 'utf-8')`**: Synchronously reads a file's content. It's simple and great for CLI tools where blocking the event loop is acceptable.
- **`JSON.parse(fileContent)`**: Parses a string of JSON content into a JavaScript object.

  ```typescript
  import fs from "fs";

  const filePath = process.argv[2];
  const fileContent = fs.readFileSync(filePath, "utf-8");
  const jsonData = JSON.parse(fileContent);
  ```

---

## 8. Q&A: Fixing the Build Errors

### Q: What was the problem and what changes did you make?

**A:** The core problem was a mismatch between your code, which used modern ES Module syntax (`import`/`export`), and your project configuration, which was not set up to handle it. This caused a cascade of errors.

Here is a breakdown of the fixes:

1. **`package.json`**: Added `"type": "module"`.
   - **What it does**: This tells the Node.js runtime to treat all `.js` files in the project as modern ES Modules, not older CommonJS modules.
   - **How it helped**: This was the most critical fix. It aligned the project's runtime environment with the code's syntax, resolving the initial errors about using `import` in a CommonJS file.

2. **`tsconfig.json`**: Added `"node"` to the `types` array.
   - **What it does**: This tells the TypeScript compiler to load the global type definitions for the Node.js runtime environment.
   - **How it helped**: This fixed the "Cannot find name 'process'" and "Cannot find module 'fs'" errors. Without this, TypeScript had no knowledge of these fundamental Node.js APIs.

3. **Import Paths**: Appended `.js` to relative imports (e.g., `./validate.js`).
   - **What it does**: When using ES Modules in Node.js, the official standard requires that relative import paths include the file extension.
   - **How it helped**: The `"module": "nodenext"` setting in your `tsconfig.json` enforces this rule. By adding `.js`, we made the import paths compliant with the modern ES Module specification that the Node.js runtime expects.

### Q: Why did my code seem to work in the editor before, and why add `.js` to a `.ts` file?

**A:** This is due to the difference between your editor and the compiler, and how modern modules work.

1. **Editor Magic**: Your code editor uses the TypeScript Language Server, which is smart enough to resolve `from './validate'` to `validate.ts` for in-editor features like autocompletion and error checking. This is a **development-time convenience**.

2. **Compiler Reality**: The `tsc` compiler is stricter. When you configure your project as a modern ES Module (`"type": "module"` and `"module": "nodenext"`), the compiler's job is to produce JavaScript that the Node.js runtime can execute.

3. **Why `.js`?**: You have to write your import paths not for the files that exist now (`.ts`), but for the files that **will exist after compilation (`.js`)**. The Node.js runtime executes the final JavaScript in your `dist` folder, and it needs the full filename, including the `.js` extension, to find the module. You are essentially writing your imports for the future, compiled output.

### Q: Can you explain the runtime, `@types/node`, and the difference between the `package.json` and `tsconfig.json` module settings?

**A:**

- **Runtime (Node.js)**: This is the environment where your code is executed. It only understands JavaScript. It provides server-side APIs like `fs` (File System) and the global `process` object.

- **`@types/node`**: This is a package containing **type declaration files** (`.d.ts`). These files act like a dictionary, describing the shape of all of Node.js's JavaScript APIs for TypeScript. Installing it and adding `"types": ["node"]` to `tsconfig.json` is how TypeScript learns about `process`, `fs`, and other Node.js features.

- **Configuration Duo**:
  - **`"type": "module"` (in `package.json`)**: This is a setting for the **Node.js runtime**. It tells Node.js to treat the `.js` files in this project as ES Modules.
  - **`"module": "nodenext"` (in `tsconfig.json`)**: This is a setting for the **TypeScript compiler**. It tells the compiler, "My target is a modern Node.js runtime, so enforce all of its rules (like requiring file extensions in imports)."

In short, `package.json` sets the rules for the destination (the runtime), and `tsconfig.json` tells the factory (the compiler) to build according to those rules.

---

## 9. Q&A: Jest, Testing, and Publishing

### Q: For imports in Jest tests, do I still need to use the `.js` extension?

**A: Yes, you should continue to use the `.js` extension even in your test files.**

Here's why:

- **Consistency**: It keeps your entire codebase consistent. The same module resolution rules should apply everywhere.
- **Jest's Transformation**: Jest uses a transformer (like `ts-jest`) to compile your TypeScript on the fly. This transformer is smart enough to understand that when you write `import ... from '../src/validate.js'`, it should actually look for and compile `../src/validate.ts`.
- **Future-Proofing**: Sticking to the official ES Module standard is the most robust and future-proof way to write your code.

### Q: Will my test files be included in the package for other people?

**A: No, your test files will not (and should not) be included when you publish your package to npm.**

This is handled by two primary mechanisms:

1. **The `.npmignore` file**: This file tells `npm` which files and folders to **exclude** when you run `npm publish`. A standard setup will always include the `test/` directory in this file. If you don't have one, `npm` will use your `.gitignore` file instead.

2. **The `files` field in `package.json` (Recommended)**: This field is a "whitelist" that tells npm to **only** include the specified files and folders. This is the best approach.

   A common and highly recommended configuration is:

   ```json
   // In package.json
   "files": [
     "dist"
   ]
   ```

   This tells npm to **only publish the `dist` folder**. Since this folder contains your compiled JavaScript and type declaration files, it's all a user needs. Your source code (`src`), tests (`test`), and configuration files are all excluded, keeping your published package small and clean.

### Q: How do I configure Jest for TypeScript with ES Modules?

**A: Configuring Jest for TypeScript + ES Modules requires several specific settings.**

This is more complex than regular Jest setup because:

1. Jest was originally built for CommonJS
2. ES Module support in Node.js is still experimental (for VM contexts)
3. TypeScript needs to be compiled on-the-fly during testing

#### Step 1: Install Required Packages

```bash
npm install --save-dev jest @types/jest ts-jest
```

#### Step 2: Update `package.json` Test Script

Add the `NODE_OPTIONS` flag to enable ES modules in Jest:

```json
{
  "scripts": {
    "test": "NODE_OPTIONS=--experimental-vm-modules jest"
  }
}
```

**What `--experimental-vm-modules` does:**

- Enables Node.js's experimental support for ES modules in VM (Virtual Machine) contexts
- Jest runs tests in isolated VMs, so this flag is required for `import`/`export` to work
- This is a **Node.js flag**, not a Jest flag
- It's marked "experimental" by Node.js, but it works reliably in practice

**Documentation Source:** [Jest ESM Guide](https://jestjs.io/docs/ecmascript-modules)

#### Step 3: Create `jest.config.js`

**Important:** Use ES module syntax (not CommonJS) since your project has `"type": "module"`:

```javascript
/** @type {import("jest").Config} **/
export default {
  // Use ts-jest's ESM preset
  preset: "ts-jest/presets/default-esm",

  // Run tests in Node.js environment
  testEnvironment: "node",

  // Treat .ts files as ES modules
  extensionsToTreatAsEsm: [".ts"],

  // Map .js imports to .ts files
  moduleNameMapper: {
    "^(\\.{1,2}/.*)\\.js$": "$1",
  },

  // Configure ts-jest to use ESM
  transform: {
    "^.+\\.tsx?$": [
      "ts-jest",
      {
        useESM: true,
      },
    ],
  },
};
```

#### Understanding Each Configuration Option

**1. `preset: "ts-jest/presets/default-esm"`**

- **What it does:** Loads a pre-configured set of options for TypeScript + ES modules
- **Why needed:** Provides sensible defaults for TypeScript compilation, module resolution, and file extension handling
- **Source:** [ts-jest ESM Guide](https://kulshekhar.github.io/ts-jest/docs/guides/esm-support#using-esm-presets)

**2. `testEnvironment: "node"`**

- **What it does:** Tells Jest to use a Node.js environment (not browser/jsdom)
- **Why needed:** Your code is meant to run in Node.js, not a browser

**3. `extensionsToTreatAsEsm: [".ts"]`**

- **What it does:** Tells Jest to treat `.ts` files as ES modules (not CommonJS)
- **Why needed:** By default, Jest might assume `.ts` files are CommonJS; this ensures `import`/`export` work correctly
- **Source:** [Jest ESM Documentation](https://jestjs.io/docs/ecmascript-modules) - Step 4 says:
  > If you want to treat other file extensions (such as `.jsx` or `.ts`) as ESM, please use the `extensionsToTreatAsEsm` option.

**4. `moduleNameMapper: { "^(\\.{1,2}/.*)\\.js$": "$1" }`**

- **What it does:** Transforms import paths using regex pattern matching
- **Why needed:** Your code imports with `.js` extensions (required for ES modules), but the actual files are `.ts`
- **Example transformation:**

  ```typescript
  import { validatePizza } from "../src/validate.js";
  // Jest looks for: ../src/validate (without .js, finds .ts file)
  ```

- **Breaking down the regex:**
  - `^` - Start of string
  - `(\\.{1,2}/.*)` - Capture group: `./` or `../` followed by anything
  - `\\.js$` - Ends with `.js`
  - `$1` - Replace with capture group 1 (the path without `.js`)
- **Source:** [ts-jest ESM Guide](https://kulshekhar.github.io/ts-jest/docs/guides/esm-support#configure-jest-config) mentions using `moduleNameMapper` to instruct Jest to load the correct ESM files

**5. `transform` with `useESM: true`**

- **What it does:** Configures ts-jest (the TypeScript transformer) to:
  - Process `.ts` and `.tsx` files matching the regex pattern `^.+\\.tsx?$`
  - Compile them with ES module output (not CommonJS)
- **Why needed:** TypeScript can compile to either CommonJS or ES modules. `useESM: true` tells ts-jest to output ES modules
- **Source:** [ts-jest ESM Guide](https://kulshekhar.github.io/ts-jest/docs/guides/esm-support#not-using-esm-presets) explicitly shows:

  ```typescript
  transform: {
    [ESM_TS_TRANSFORM_PATTERN]: [
      'ts-jest',
      { useESM: true },
    ],
  }
  ```

#### Common Pitfall: `ts-jest config:init`

The `ts-jest config:init` command generates a **CommonJS** config file by default:

```javascript
const { createDefaultPreset } = require("ts-jest"); // ❌ CommonJS syntax
```

This won't work in an ES module project (`"type": "module"` in package.json) because `require()` is not available. You must use the ES module configuration shown above instead.

#### The Full Picture: How Jest + TypeScript + ESM Work Together

```
Your Code (.ts files with import/export)
          ↓
     Test Files (.test.ts with import/export)
          ↓
   Jest (configured for ESM)
          ↓
NODE_OPTIONS=--experimental-vm-modules
   (enables ES modules in Jest's VM)
          ↓
   ts-jest (transforms .ts → .js)
   (with useESM: true for ES module output)
          ↓
moduleNameMapper (fixes .js import paths)
   (maps .js imports to .ts files)
          ↓
Tests Execute Successfully! ✅
```

---

## 10. Q&A: Understanding the `as` Keyword (Type Assertion)

### Q: What is the `as` syntax and how does it work?

**A:** The `as` keyword in TypeScript is used for **type assertion**. It's a way for you to tell the TypeScript compiler, "Trust me, I know what I'm doing. I know more about the type of this value than you do."

This is a **compile-time only** feature. It has no effect on the runtime behavior of your code:

- It does **NOT** perform any runtime checks.
- It does **NOT** change the value or structure of the object.
- It does **NOT** "cast" the object in the way languages like C# or Java do.

The `as` keyword is purely a message from you to the TypeScript compiler to override its inferred type and prevent a compile-time error.

### Q: Can you use `as` to cast a "bad" object to a valid type?

**A: Yes, you can, and this is precisely why `as` can be dangerous.**

You can absolutely lie to the compiler with a type assertion. For example, you could assert that an object with incorrect field types is a valid `Pizza`:

```typescript
const bad_pizza = {
  size: "small", // This is a string, but Pizza expects a number
  company: "Dominos", // This property doesn't exist on the Pizza type
};

// You can do this, and TypeScript will NOT complain at compile time.
const myBadPizza = bad_pizza as Pizza;
```

At compile time, TypeScript now believes `myBadPizza` is a valid `Pizza`. However, your program will likely crash or behave unexpectedly at **runtime** when it tries to use the incorrectly typed properties.

### Summary: Type Assertion (`as`) vs. Runtime Validation (Zod)

- **Type Assertion (`as`)**: A **compile-time** tool to tell the compiler what a type is. It provides **no runtime safety**. It's useful only when you are getting data from a source you absolutely trust or have already validated.

- **Runtime Validation (like Zod)**: A **runtime** tool that actively checks if an object matches a specific shape. It **proves** that the data is correct and provides **real safety** for data coming from external sources (like a file, an API call, or user input).

**Golden Rule:** Use runtime validation (like Zod) whenever you receive data from an external source. Use type assertions (`as`) sparingly and only when you are 100% certain about the type of a value that TypeScript cannot figure out on its own.

---

## 11. Understanding the Package Ecosystem

### ESLint vs. @typescript-eslint/\*

**ESLint** is a JavaScript linter that analyzes your code for potential errors and enforces coding standards.

- **`eslint`**: The core ESLint package. By default, it only understands JavaScript, not TypeScript.

**@typescript-eslint** extends ESLint to understand TypeScript:

- **`@typescript-eslint/parser`**: A parser that allows ESLint to understand TypeScript code. It translates your TypeScript into a format ESLint can analyze.
- **`@typescript-eslint/eslint-plugin`**: Provides TypeScript-specific linting rules (e.g., "don't use `any`", "prefer interfaces over type aliases").

**Why both?** ESLint is the engine, `@typescript-eslint/parser` teaches it to read TypeScript, and `@typescript-eslint/eslint-plugin` gives it TypeScript-specific rules to enforce.

### @types/node vs. ts-node

These serve completely different purposes:

**`@types/node`**: Type definitions for Node.js.

- Contains `.d.ts` files that describe the types of all Node.js built-in modules (`fs`, `http`, `process`, etc.).
- Needed at **compile time** so TypeScript can type-check your code.
- Does NOT contain any executable code.
- **Always needed** for any Node.js TypeScript project.

**`ts-node`**: A TypeScript execution engine.

- Allows you to run TypeScript files directly with Node.js without manually compiling them first.
- Useful for development servers, scripts, or rapid iteration.
- Contains executable code that compiles and runs TypeScript on the fly.
- **Only needed during development** for quick iteration.

**Example:**

- Without `ts-node`: `tsc my-script.ts && node my-script.js`
- With `ts-node`: `ts-node my-script.ts`

### When Do You Need ts-node?

**For npm packages (like this project):** You **don't need** `ts-node`.

- Your workflow: Write TypeScript → Run `tsc` to compile → Publish JavaScript to npm
- Users only receive and run the compiled JavaScript files

**For development servers:** `ts-node` is very useful.

```bash
# Development - quick iteration
ts-node server.ts

# Production - always compile first
tsc
node dist/server.js
```

**For development scripts:**

```bash
ts-node scripts/seed-database.ts  # Quick one-off scripts
```

### Production: Always Compile to JavaScript

**Even for backend servers in production, you compile TypeScript to JavaScript.**

**Why?**

1. **Performance**: Pre-compiled JavaScript runs faster than on-the-fly compilation
2. **Reliability**: Catch compilation errors before deployment, not in production
3. **Lighter deployments**: Production doesn't need TypeScript or ts-node installed

**Key takeaway:** TypeScript is a development tool. Node.js always runs JavaScript in production.

### Prettier

**Prettier** is an opinionated code formatter. Unlike ESLint (which finds problems), Prettier only cares about **how your code looks**—indentation, line length, quote style, etc.

- It automatically formats your code to a consistent style.
- It has very few configuration options by design (to avoid bikeshedding).
- It works with JavaScript, TypeScript, JSON, Markdown, and many other languages.

---

## 12. ESLint and Prettier Configuration

### ESLint Configuration (`eslint.config.js`)

The configuration includes the following custom rules:

1. **`@typescript-eslint/no-unused-vars`**: Errors on unused variables, but allows variables starting with `_` (useful for intentionally unused parameters).

2. **`@typescript-eslint/explicit-function-return-type`**: Warns if function return types are not explicitly declared (helps with code clarity and type safety).

3. **`@typescript-eslint/no-explicit-any`**: Errors when the `any` type is used (enforces proper typing).

4. **`@typescript-eslint/prefer-const`**: Errors when variables that are never reassigned are declared with `let` instead of `const`.

5. **`no-console`**: Warns when `console.log` is used (allows `console.warn` and `console.error` for legitimate logging).

6. **`eqeqeq`**: Requires strict equality (`===` and `!==`) instead of loose equality (`==` and `!=`).

### Prettier Configuration (`.prettierrc`)

The configuration includes the following settings:

1. **`semi: true`**: Requires semicolons at the end of statements.

2. **`singleQuote: true`**: Uses single quotes instead of double quotes.

3. **`tabWidth: 2`**: Sets indentation to 2 spaces.

4. **`trailingComma: "es5"`**: Adds trailing commas where valid in ES5 (objects, arrays, etc.). This makes git diffs cleaner.

5. **`printWidth: 100`**: Sets the maximum line length to 100 characters.

6. **`arrowParens: "always"`**: Always includes parentheses around arrow function parameters, even for single parameters.

### Running the Tools

- **Lint your code**: `npm run lint`
- **Format your code**: `npm run format`

---

## 13. Building and Publishing

### `"files"` in package.json vs. `"exclude"` in tsconfig.json

These two settings serve different purposes and are used by different tools:

**`"files": ["dist"]` in package.json:**

- **Used by:** `npm publish`
- **Purpose:** Controls what gets published to npm
- **Effect:** Only the `dist/` folder will be included when someone installs your package

**`"exclude"` in tsconfig.json:**

- **Used by:** `tsc` (TypeScript compiler)
- **Purpose:** Controls what TypeScript compiles
- **Effect:** Prevents TypeScript from trying to compile files in `test/`, `dist/`, etc.

**Why you need both:** Even though `"files"` tells npm what to publish, the TypeScript compiler doesn't read `package.json` to determine what to compile. Without `"exclude"`, TypeScript will try to compile test files and throw errors when it finds files outside your `rootDir`.

### The Shebang Line for CLI Tools

For executable scripts (like CLI tools), you need a **shebang** at the top of your file:

```typescript
#!/usr/bin/env node
// Rest of your code...
```

**What it does:**

- `#!` is called a "shebang" - it tells the system this is an executable script
- `/usr/bin/env node` finds the Node.js executable in your PATH and uses it to run the file
- Without this, the shell tries to execute JavaScript as a shell script, which causes errors

This shebang line is preserved when TypeScript compiles to JavaScript, making your CLI tool executable.

### TypeScript Users and Your JavaScript Package

**Can TypeScript users use your JavaScript package?** Yes! Seamlessly.

When you build with `"declaration": true` in `tsconfig.json`, TypeScript generates `.d.ts` type declaration files alongside your JavaScript:

```
dist/
  ├── index.js          # JavaScript code (runtime)
  ├── index.d.ts        # Type declarations (compile-time)
  ├── validate.js
  └── validate.d.ts
```

**For TypeScript users:**

```typescript
import { validatePizza } from "cis-1962-validate-pizza";
// Gets full type safety, autocomplete, and IntelliSense
```

TypeScript loads:

1. JavaScript from `dist/index.js` for runtime execution
2. Type definitions from `dist/index.d.ts` for compile-time type checking

**For JavaScript users:**

```javascript
const { validatePizza } = require("cis-1962-validate-pizza");
// Works fine, just no type checking
```

**Key takeaway:** Publishing JavaScript + type declarations = best of both worlds. Your package works for everyone, and TypeScript users get full type safety.

### Testing Your Package Locally with npm link

Before publishing, test your package as if someone installed it:

**Step 1: Build your package**

```bash
npm run build
```

**Step 2: Create a global link**

```bash
npm link
```

This creates a global symlink. Now your CLI command is available globally, and other projects can import your package.

**Step 3: Test the CLI**

```bash
pizza-validator path/to/test-pizza.json
```

**Step 4: Test as a library in another project**

```bash
cd /path/to/test-project
npm link cis-1962-validate-pizza
```

Then import and use it in your test project.

**Step 5: Unlink when done**

```bash
# In your test project
npm unlink cis-1962-validate-pizza

# In your package directory
npm unlink -g
```

**Pro tip:** After linking, you only need to rebuild (`npm run build`) to test changes. The link automatically uses your latest build.
